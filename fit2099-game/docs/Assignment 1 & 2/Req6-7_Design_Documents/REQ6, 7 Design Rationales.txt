



__________________________________________________ REQ6: Monologue __________________________________________________


CLASS CONTRACTS

Speakable interface contract
Pre-conditions/requirements:
- Any classes requiring a SpeakAction implement this interface.
Post-conditions/responsibilities:
- Will provide a method which generates an appropriate SpeakAction for the class.

SpeakAction contract
Pre-conditions/requirements:
- The sentence to speak is provided in the constructor.
Post-conditions/responsibilities:
- Will speak the given sentence in the console when executed.

SpeakBehaviour contract
Pre-conditions/requirements:
- Any classes requiring the ability to autonomously speak contain this behaviour.
- Any classes containing this behaviour implement the Speakable interface.
Post-conditions/responsibilities:
- Will provide a method which returns an appropriate SpeakAction for the class.

Toad contract
Pre-conditions/requirements:
- The allowableActions method is called whenever Toad should speak to the Player.
Post-conditions/responsibilities:
- The allowableActions method will return a SpeakAction that can be executed for the player to speak with Toad.

END CLASS CONTRACTS


DESIGN VERSION 2

The initial abstraction was wrong, and the design broke the Single Responsibility Principle (SRP). If there are
extensions for other actors to speak to the console, they will each need to implement their own logic for choosing
a sentence. By SRP, this should be implemented in the class performing the action. For example, a method in Toad which
selects which sentence Toad speaks. This can be abstracted into an interface representing all classes implementing a
method to select a sentence to speak. This method in the Speakable interface would then return a generic SpeakAction
which displays the chosen sentence.
In order for the player to control when Toad speaks, and have an action to speak with Toad, the correct SpeakAction for
Toad must be available in the Player.playTurn method, which can only occur if it is returned by the
Toad.allowableActions method.
Some actions can be autonomously chosen by the actor, such as MoveActorAction and DoNothingAction for enemies, while
others can only be executed by the player, such as speaking with Toad. The requirement of the player speaking with Toad
is satisfied with SpeakAction and the Speakable interface, however there may be extensions for Toad or other actors to
speak autonomously. In this case it would make sense to have a SpeakBehaviour, so actors can choose between a
SpeakAction generated in the behaviour or another action generated by another behaviour.
Toad currently does not speak except when the player selects the action, so it does not need the behaviour now. It is
only included for game extensions.

END DESIGN VERSION 2


DESIGN VERSION 1

This assumes the existence of a Toad class from REQ5. The main feature of this requirement is an action to speak with
Toad, which will be implemented with a new SpeakWithToadAction class, which will extend the abstract Action class like
all other actions in the game. The action will first check whether the player holds a Wrench object and whether the
Power Star status is active, and then randomly select a sentence accordingly. The action will already have access to
the player Actor as it will override the execute method from Action, which accepts the Actor.
To contain all possible sentences, one option is to store a collection of strings in the Toad class. However, if there
are extensions to include more NPCs which have a speak action, they will have unique sentences and may share common
sentences. To follow the Don't Repeat Yourself (DRY) principle, the common attributes should be extracted into a speak
action superclass, and the unique ones added in each subclass like SpeakWithToadAction. Therefore, to maintain
extensibility, there will be an abstract SpeakAction which contains the common sentences, and the SpeakWithToadAction
will extend this class and add the unique sentences.


Abstract SpeakAction contract
Preconditions/requirements:
- None.
Post-conditions/responsibilities:
- Provide a collection of common sentences to be used by all speak actions.

SpeakWithToadAction contract:
Pre-conditions/requirements:
// EDIT - This is not implemented as it is not currently possible for Enemies to execute the SpeakWithToadAction.
- The actor performing the action is the player.
- The player provides access to search their inventory and active   capabilities.
- The superclass for speak actions provides common sentences.
Post-conditions/responsibilities:
- Will speak a sentence on behalf of Toad in the console.

END DESIGN VERSION 1




__________________________________________________ REQ7: Reset Game __________________________________________________


CLASS CONTRACTS

ResetAction contract
Pre-conditions/requirements:
- The actor performing the action must be the player (i.e. NPCs cannot reset).
Post-conditions/responsibilities:
- Will reset all instances as required.

Resettable interface contract
Pre-conditions/requirements:
- Any classes responding to a reset must implement this interface.
Post-conditions/responsibilities:
- Will provide a method which executes reset operations for the class.

ImmovableResettable interface contract
Pre-conditions/requirements:
- Any classes implementing this can only depend on their Location for the reset.
Post-conditions/responsibilities:
- Will provide a method which supplies the class with resources required for the reset.

MovableResettable interface contract
Pre-conditions/requirements:
- Any classes implementing this can only depend on their current GameMap for the reset.
Post-conditions/responsibilities:
- Will provide a method which supplies the class with resources required for the reset.

ResetManager contract
Pre-conditions/requirements:
- All objects which are intended to be reset have implemented the Resettable interface.
Post-conditions/responsibilities:
- Informs whether a reset is available (for an accessor).
- Resets all appropriate instances (for the run method).
- Will only reset the game once.
These responsibilities are handled by different methods, so the Command-Query Separation Principle is not
breached.

ResetResources contract
Pre-conditions/requirements:
- All objects requiring additional reset resources contain this class.
Post-conditions/responsibilities:
- Provides reset resources for all Resettable classes.

END CLASS CONTRACTS


DESIGN VERSION 3

To fix the problem of Resettable instances requiring different reset resources, create a new class ResetResources which
contains resources needed by all Resettable objects for the reset. The Resettable objects can then contain an instance
of this class and use its resources as required. Classes that don't require any additional resources, such as
Player, do not need to contain this class. This does not break the Separation of Concerns Principle (SCP) since the
ResetResources class only needs to contain all possible resources required by a reset, and does not need to know about
the requirements of specific Resettable classes. This follows DRY because classes that need the same resources (such as
Tree and Coin) do not repeat the same attributes in each class (i.e. Location is stored in ResetResources only and not
repeatedly in Tree, Coin, and any other Resettable classes requiring their location).
Note on resetting the Player.
The player needs to remove certain effects from their capabilities and effects from items in the inventory. The effects
that should be removed on a reset may differ for each Resettable class, so by SRP the Player should know all effects
that should be removed. This can be contained as a collection of Status enums within player.

END DESIGN VERSION 3


DESIGN VERSION 2

Classes that need to implement a reset require resources for their reset operations.
- Tree objects require their Location object to change the ground.
- Enemy objects require their GameMap object to remove themselves.
- Access to the Player object from resetInstance already provides the required resources.
- Coin objects require their Location object to remove themselves.

For the code to be extensible and follow Separation of Concerns, any new classes responding to a reset should be
responsible for their own reset operations and any resources required by those operations. Every class has different
resource requirements for responding to the reset, so any related methods should not be part of the Resettable
interface as they are not common to all Resettable instances, so this would break the Interface Segregation Principle
(ISP). However, two more interfaces can be made, ImmovableResettable and MovableResettable.
ImmovableResettable will
represent any Resettable classes that do not change location and only require their Location object to implement the
reset (note: it may be a portable item where the player can drop it somewhere else, but it can't change locations on
its own).
MovableResettable will represent any Resettable classes that do change locations automatically throughout the
game and require their GameMap object to implement the reset (usually actors).
These smaller interfaces can be applied to the above four classes with breaking ISP. The ResetManager does not need to
be aware of the ImmovableResettable and MovableResettable interfaces: they are only used internally by the classes
implementing them. It is then the responsibility of each class to call appropriate methods from its interface to
maintain its required reset resources. These may need to be called from the constructor or from the tick or playTurn
method, depending on the interface. This will require a new parameter or an overloaded constructor with parameters
containing the relevant information. A downside of this is that all the constructor calls will need to be traced and
updated to pass the relevant information at instantiation. If an overloaded constructor is used, the existing
implementation won't need to change entirely: only the instantiation of resettable objects during the game will need to
change.
Clarification:
Using a Resettable abstract class instead of the interface could contain all reset resources and would remove the need
for the ImmovableResettable and MovableResettable interfaces. This cannot be done because Java doesn't allow multiple
inheritance and the diamond problem.

END DESIGN VERSION 2


DESIGN VERSION 1

This assumes the existence of the classes Coin, Enemy, Player, and Tree. This requirement needs to call a method in
all of the above classes to perform an appropriate reset on each instance. This reset method can be extracted into an
interface, which already exists in the game package: the Resettable interface. Therefore, the first modifications
needed are to ensure the above four classes implement the Resettable interface, and perform the necessary reset actions
for that class. The interface is small (only two methods) so ISP is not breached.
The next feature is that the player needs to have a reset action which can only be used once. This means that some
class needs to know about and be responsible for the number of times the reset has occured. According to the Single
Responsibility Principle (SRP), this should be the new ResetAction class, as it is responsible for executing the reset.
However, the ResetAction should not be available to the player if it has been used. If it is available, it should be
added to the actions list in the Player playTurn method, so that only the player can reset the game. This means
whatever class manages the reset availability needs to provide information to the Player playTurn class to
conditionally add the ResetAction to the menu. Therefore it should not be the ResetAction class, as it would break the
SRP, since it is encapsulating both the reset operations themselves and the management of the reset availability to the
menu and actions list.
Another class is required to manage the reset availaiblility, and provide information to the Player playTurn method to
conditionally make the reset action available. Looking at the existing ResetManager class in the game package, the run
method can be used to execute the reset on all objects, and set a flag indicating that the single reset is complete. An
accessor can be added to communicate this flag to the playTurn method, which solves the problem.
An undesired effect of this solution is that DRY and the Dependency Inversion Principle (DIP) are somewhat breached, as
ResetAction depends on another concrete class (ResetManager) and the execution of ResetAction.execute() is to call
ResetManager.run() to do the desired task. However, the ResetAction is necessary to enable the action in the menu, and
the ResetManager is necessary as described above and already exists.
The contracts for the new and modified classes are as follows.

END DESIGN VERSION 1

